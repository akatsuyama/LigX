{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"What is LigX","text":"<p>LigX is a python module designed for ligand generation and extension within the binding site of a target molecule, following a fragment-based approach.</p>"},{"location":"#highlights-of-the-ligx","title":"Highlights of the LigX","text":""},{"location":"#1-synthetic-accessibility","title":"1. Synthetic Accessibility","text":"<p>During the fragment-linking process, LigX incorporates the concept of retrosynthetic analysis to ensure the synthetic accessibility of the generated molecules.</p>"},{"location":"#2-structural-diversity","title":"2. Structural Diversity","text":"<p>LigX employs a breadth-first search strategy to systematically explore a wider range of chemical space.</p>"},{"location":"#3-generating-molecules-as-3d-structures","title":"3. Generating Molecules as 3D Structures","text":"<p>LigX generate multiple compounds as a xyz file format. This ensures that the generated structure satisfies the structural requirements of the target protein. Furthermore, users can conduct subsequent more reliable evaluations (e.g. docking simulation and molecular dynamics simulation) based on this structure, allowing them to identify compounds that show both high affinity and synthetic feasibility from a large pool of candidates.</p>"},{"location":"#access","title":"Access","text":"<ul> <li> <p>Source code</p> <ul> <li>Github</li> </ul> </li> <li> <p>Author</p> <ul> <li>Akira Katsuyama</li> </ul> </li> <li> <p>Contributor</p> <ul> <li>Kazuki Hoshi</li> </ul> </li> </ul>"},{"location":"calc_interaction/","title":"Score Calculation for Breadth-First Search Based on Interaction Energy","text":"<p>Physically based interaction between each fragment and proteins is calculated by Lennard-Jones potential and Coulomb potential as a following equation.</p> \\[ E = \\frac{ \\left\\{ \\displaystyle \\sum 4\\varepsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6 \\right] \\;+\\; \\alpha \\displaystyle \\sum \\frac{Q_1 \\cdot Q_2}{4\\pi \\varepsilon_0\\, r} \\right\\} }{L} \\] <ul> <li>\\(\\alpha\\): hyper parameter  </li> <li>\\(r\\): distance  </li> <li>\\(L\\): number of heavy atoms</li> </ul> <p>These interactions are calculated only for atoms within the cutoff value (default value is 10 \u00c5). Except for hydrogen atoms, the uniform LJ parameters and charge parameters are applied. For hydrogen atoms, two types of parameters are applied by classifying them into polar hydrogen and nonpolar hydrogen. The values of hyperparameters and the availability of L can be modified in the input file. Fragments with high E-values undergo rollout, and their E-values are updated. The score for selection is calculated using the following equation, based on this E value and the number N, which is the number of times the fragment has been selected for a given initiator.</p> \\[ \\mathrm{score} = \\sqrt{2}\\,\\sqrt{\\frac{\\log n}{N} + \\frac{1}{E_{\\min}-\\mathrm{cutoff}}}\\,(E-\\mathrm{cutoff}) \\] <ul> <li>\\(E_{\\min}\\): The highest interaction among the possible fragments in this stage.</li> <li>\\(\\mathrm{cutoff}\\): Cutoff value for the standardization.</li> <li>\\(n\\): Total selection number at each initiator.</li> </ul>"},{"location":"calc_interaction/#lj-and-charge-parameters-used-in-ligx","title":"LJ and charge parameters used in LigX","text":"Atom \u03c3 (\u00c5) \u03b5 (kcal/mol) Q (e) H (non polar) 2.38760856462 0.1882800 0.09 H (polar) 0.40001352445 0.1924640 0.43 C 3.58141284692 0.2343040 0.07 N 3.52795892384 0.2928800 -0.40 O 3.02905564168 0.5020800 -0.50 F 3.02905564168 0.5020800 -0.19 P 3.83086448800 2.4476400 1.00 S 3.56359487256 1.8828000 0.12 Cl 3.31414323148 0.9623200 -0.17 Br 3.52795892384 1.3388800 -0.14 I 3.99122625727 2.1756800 -0.08 Mg 2.11142996199 0.0627600 2 Zn 1.94215920555 1.0460000 2 <p>Note: The values of \u03c3 and \u03c3 were determined based on the charmm36-jul2022.ff force field (atom types: HGA1, HGP1, CG321, NG331, OG2D1, FGR1, PG0, SG311, CLGR1, BRGR1, IGR1, MG, ZN), as provided by the MacKerell lab website.</p>"},{"location":"data-layout/","title":"Data Layout","text":""},{"location":"data-layout/#input-file-layout","title":"Input file layout","text":"<p>Directorys containing input files are placed at the same level as <code>run_ligx.py</code>. </p> <pre>\nwork_dir/\n\u251c\u2500\u2500 run_ligx.py\n\u251c\u2500\u2500 ligand_xyz/\n\u2502   \u2514\u2500\u2500 ligand_name/\n\u2502       \u251c\u2500\u2500 ligand_name.xyz\n\u2502       \u2514\u2500\u2500 charge.txt\n\u251c\u2500\u2500 protein_xyz/\n\u2502   \u2514\u2500\u2500 protein_name.xyz\n\u251c\u2500\u2500 fragment/ (optional)\n\u2502   \u251c\u2500\u2500 ***\n\u2502   \u251c\u2500\u2500 .\n\u2502   \u2514\u2500\u2500 .    \n\u2514\u2500\u2500 rollout_fragment/ (optional)\n    \u251c\u2500\u2500 ***\n    \u251c\u2500\u2500 .\n    \u2514\u2500\u2500 .\n</pre> <p>The directory names <code>ligand_xyz/</code> and <code>protein_xyz/</code> are specified as LigX default values. <code>ligand_name.xyz</code> is a xyz file of initiator prepared according to the instructions on Initiator Preparation. The results will be output to <code>work_dir</code>. These name can be specified by Attributes of LigXRun.</p> <p>Note: The <code>fragment</code> and <code>rollout_fragment</code> in the above example illustrate the layout when using external fragments. These two are optional because LigX contains default fragment sets required for the execution. For details, refer to Using User-Specified Fragments].</p>"},{"location":"data-layout/#output-file-layout","title":"Output file layout","text":"<p>Output files in LigX are stored in <code>result/</code>. Log files are stored in current directory. <code>result_all_total_conf_(number).xyz</code> is suitable for the docking simulations. This file can be visualized using programs such as PyMOL. <code>result_score.csv</code> contains SMILES and interaction energies roughlly estimated by LigX. (Using this value for evaluation of compounds is not recommended. Please use other reliable docking tools for affinity evaluation.)</p> <p>After the termination, <code>result_conf_(number)/</code> will be created that strores all xyz files and charge parameters.</p> <pre>\nwork_dir/\n\u251c\u2500\u2500 run_ligx.py\n\u251c\u2500\u2500 .\n\u251c\u2500\u2500 .\n\u251c\u2500\u2500 .\n\u251c\u2500\u2500 logfile.log\n\u251c\u2500\u2500 paramfile.log\n\u2514\u2500\u2500 result/\n    \u251c\u2500\u2500 image_ligx/\n    \u2502   \u251c\u2500\u2500 chemical_structure1.png\n    \u2502   \u2514\u2500\u2500 .\n    \u251c\u2500\u2500 result_all_total_conf_(number).xyz  #suitable for the following docking simulations.\n    \u251c\u2500\u2500 result_conf_(number)/\n    \u2502   \u251c\u2500\u2500 sorted_structures1/\n    \u2502   \u251c\u2500\u2500 .\n    \u2502   \u251c\u2500\u2500 .\n    \u2502   \u251c\u2500\u2500 sorted_structures.xyz\n    \u2502   \u251c\u2500\u2500 .\n    \u2502   \u2514\u2500\u2500 .\n    \u2514\u2500\u2500 result_score.csv  #contains interaction energy and SMILES\n</pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#requirements","title":"Requirements","text":"<p>This program is cross-platform and can be used on MacOS, Windows, and Ubuntu operating systems. We tested on the python 3.9.23. It requires to install several modules. </p> <ul> <li>Required</li> <li><code>numpy (2.0.2)</code></li> <li>Recommended</li> <li><code>rdkit</code> \u2014 must be a build that includes the <code>rdkit.Chem.rdDetermineBonds</code> module.     Example of a verified build: <code>rdkit=2025.03.5=py39h364ec62_0</code> (from <code>conda-forge</code>).     If a version of RDkit that satisfies the requirements is not installed, SMILES filter will be unavailable. LigX automatically switches the SMILES filter depending on the environment. Even if the SMILES filter is unavailable, compound generation in xyz format can be performed.</li> </ul> <p>Notes Pinning to <code>rdkit=2025.03.5</code> ensures reproducibility. You may relax the build pin to any version that ships <code>rdkit.Chem.rdDetermineBonds</code>.</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#pip-and-conda","title":"pip and conda","text":"<pre><code>conda create -n ligx python=3.9 numpy pip -c conda-forge\nconda activate ligx\npip install git+https://github.com/akatsuyama/LigX.git\n</code></pre> <p>Installation of RDkit (recommended)</p> <pre><code>conda install -c conda-forge rdkit\n</code></pre>"},{"location":"getting-started/#quick-start","title":"Quick Start","text":"<p>Please prepare a python script to run LigX program (example: <code>run_ligx.py</code>).  Key paratemers and attributes are summarized in LigX Functions-LigXRun. It is recommended that key parameters linknum and outnum are specified in the python script.</p> <pre><code>#example (linknum = 4 and outnum = 3000)\n\n#import LigX package and class LigXRun\nfrom LigX import LigXRun\n\ninput_file = LigXRun(linknum=4,outnum=3000)\ninput_file.exec_ligx()\n</code></pre> <p>Please refer to Data Layout and place the input files in their designated directories accordingly.</p>"},{"location":"getting-started/#running","title":"Running","text":"<pre><code>python run_ligx.py\n</code></pre> <p>For output structure and file locations, please refer to Data Layout.</p>"},{"location":"referemce_docs/","title":"Reference","text":""},{"location":"resources/","title":"LigX Functions","text":""},{"location":"resources/#LigX.LigX_core.LigXRun","title":"LigXRun","text":"<p>Core class in LigX</p>"},{"location":"resources/#LigX.LigX_core.LigXRun--key-parameters","title":"Key Parameters","text":"<p>linknum (int):     Maximum number of fragment linkings. (default: 5) outnum (int):     Number of structures to generate in this run. (default: 2000) ex_frag (str):     Relative path to the external fragment set specified by the user.     (example: 'external_fragment/fragment') ex_rollfrag (str):     Relative path to the external rollout fragment set specified by the user.     (example: 'external_fragment/rollout_fragment')</p>"},{"location":"resources/#LigX.LigX_core.LigXRun--key-attributes","title":"Key Attributes","text":"<p>smiles_filter (bool):  Set to <code>False</code> when explicitly turning off the SMILES filter. LigX program automatically sets the value to <code>False</code> in environments where RDkit is unavailable.(default: <code>True</code>) result_dir (str): Directory name where output is saved. (default: 'result') ligand_xyz (str): Directory name where the ligand (initiator) structure used for input is stored. (default: 'ligand_xyz') dir_protein_xyz (str): Directory name where the protein structure used for input is stored. (default: 'protein_xyz') cutoff_score_init (float): Initial cutoff value for ligand selection. (default: 15) cutoff_score_fin (float): The maximum cutoff value that increases with the number of generated structures. Increases linearly from cutoff_score_init. (default: 15) sigma_sum_cut (float): Collision detection value for stetic clash between fragments and initiators. Reducing this value increases structural flexibility, but also makes it easier to generate unreasonable structures. (default: 10) rollout_num (int): The number of fragments for which rollout is performed after evaluating the interaction of fragments. (default: 5)  clean (bool): For MacOS only. LigX detects the operating system. If running on macOS, clean will set to <code>True</code> and the program will execute clean.sh to remove automatically generated files such as .DS_Store and AppleDouble.  Set this option to <code>False</code> if you do not allow the execution of clean.sh. There is no need to configure this setting on Windows or Linux systems. (default: <code>False</code>) </p> Source code in <code>LigX/LigX_core.py</code> <pre><code>class LigXRun:\n    \"\"\"Core class in LigX&lt;br&gt;\n\n    ------------------\n    ## Key Parameters\n    **linknum** (*int*):&lt;br&gt;\n        Maximum number of fragment linkings. (default: 5)&lt;br&gt;\n    **outnum** (*int*):&lt;br&gt;\n        Number of structures to generate in this run. (default: 2000)&lt;br&gt;\n    **ex_frag** (*str*):&lt;br&gt;\n        Relative path to the external fragment set specified by the user.\n        &lt;br&gt;(example: 'external_fragment/fragment')&lt;br&gt;\n    **ex_rollfrag** (*str*):\n        Relative path to the external rollout fragment set specified by the user.\n        &lt;br&gt;(example: 'external_fragment/rollout_fragment')&lt;br&gt;\n    ------------------\n\n    ## Key Attributes\n\n    **smiles_filter** (*bool*): &lt;br&gt;\n    Set to `False` when explicitly turning off the SMILES filter.\n    LigX program automatically sets the value to `False`\n    in environments where RDkit is unavailable.(default: `True`)&lt;br&gt;\n    **result_dir** (*str*):&lt;br&gt;\n    Directory name where output is saved. (default: 'result')&lt;br&gt;\n    **ligand_xyz** (*str*):&lt;br&gt;\n    Directory name where the ligand (initiator) structure used for\n    input is stored. (default: 'ligand_xyz')&lt;br&gt;\n    **dir_protein_xyz** (*str*):&lt;br&gt;\n    Directory name where the protein structure used for input\n    is stored. (default: 'protein_xyz')&lt;br&gt;\n    **cutoff_score_init** (*float*):&lt;br&gt;\n    Initial cutoff value for ligand selection. (default: 15)&lt;br&gt;\n    **cutoff_score_fin** (*float*):&lt;br&gt;\n    The maximum cutoff value that increases with the number of\n    generated structures. Increases linearly from cutoff_score_init.\n    (default: 15)&lt;br&gt;\n    **sigma_sum_cut** (*float*):&lt;br&gt;\n    Collision detection value for stetic clash\n    between fragments and initiators. Reducing this value increases\n    structural flexibility, but also makes it easier to generate\n    unreasonable structures. (default: 10)&lt;br&gt;\n    **rollout_num** (*int*):&lt;br&gt;\n    The number of fragments for which rollout is performed after evaluating the interaction of fragments. (default: 5) &lt;br&gt;\n    **clean** (*bool*):&lt;br&gt;\n    For MacOS only. LigX detects the operating system. If running on macOS, clean will set to `True` and the program will execute clean.sh to remove automatically generated files such as .DS_Store and AppleDouble. &lt;br&gt;\n    Set this option to `False` if you do not allow the execution of clean.sh. &lt;br&gt;There is no need to configure this setting on Windows or Linux systems. (default: `False`) &lt;br&gt;\n\n    ------------------\n    \"\"\"\n    def __init__(self, linknum = None, outnum = None, ex_frag = None, ex_rollfrag = None, logfile_root = None, result_dir_root = None, paramlog_root = None, ligand_xyz_root = None, dir_protein_xyz_root = None, desired_frag_root = None, desired_frag_rollout_root = None):\n\n        if logfile_root is None:\n            self.logfile = 'logfile.log'\n        else:\n            self.logfile = logfile_root\n        if paramlog_root is None:\n            self.paramlog = 'Param.log'\n        else:\n            self.paramlog = paramlog_root\n        if result_dir_root is None:\n            self.result_dir = 'result'\n        else:\n            self.result_dir = result_dir_root\n        if ligand_xyz_root is None:\n            self.ligand_xyz = 'ligand_xyz'\n        else:\n            self.ligand_xyz = ligand_xyz_root\n        if dir_protein_xyz_root is None:\n            self.dir_protein_xyz = 'protein_xyz'\n        else:\n            self.dir_protein_xyz = dir_protein_xyz_root\n        if ex_frag is None:\n            self.fragment_set = None\n        else:\n            self.fragment_set = ex_frag\n        if ex_rollfrag is None:\n            self.rollout_set = None\n        else:\n            self.rollout_set = ex_rollfrag\n        if desired_frag_root is None:\n            self.desired_frag = None\n        else:\n            self.desired_frag = desired_frag_root\n        if desired_frag_rollout_root is None:\n            self.desired_frag_rollout = None\n        else:\n            self.desired_frag_rollout = desired_frag_rollout_root\n\n        if linknum is None:\n            self.cycle = 5\n        else:\n            self.cycle = linknum\n\n        if outnum is None:\n            self.max_conf = 2000\n        else:\n            self.max_conf = outnum\n\n        self.des_frag_cycle = -1\n        self.max_branch_core = 0\n        self.max_branch_frag = 0\n        self.result_conf = self.max_conf\n        self.evaluation_param = 'LE_interact_E'\n        self.evaluation_method = 'highest'\n        self.cutoff_score_init = 15\n        self.cutoff_score_fin = 15\n        self.rollout_num = 5\n        self.rollout_frag_max = 3\n        self.image_dir_name = 'image_ligx'\n        self.count_for_data_processing = -1\n        self.rollout_conf_inner = 1\n        self.rollout_conf_inner_des = 20\n        self.sigma_sum_cut = 10\n        self.clean = False\n        if platform.system() == 'Darwin':\n            self.clean = True\n        else:\n            self.clean = False\n\n\n\n    def exec_ligx(self):\n\n        try:\n            from rdkit import Chem\n            from rdkit.Chem import rdDetermineBonds\n        except Exception as e:\n            self.smiles_filter = False\n            red_print(\"SMILES filter disabled (RDKit import failed): \" +str(e))\n        else:\n            self.smiles_filter = True\n            from rdkit.Chem import AllChem\n            from rdkit.Chem import Draw\n            from rdkit import RDLogger\n            RDLogger.DisableLog('rdApp.*')\n            red_print(\"SMILES filter enabled\")\n\n        logfile = os.path.join(os.getcwd(),self.logfile)\n        paramlog = os.path.join(os.getcwd(),self.paramlog)\n        result_dir = os.path.join(os.getcwd(),self.result_dir)\n\n        dir_parent = os.path.join(os.getcwd(),self.ligand_xyz)\n        dir_protein_xyz = os.path.join(os.getcwd(),self.dir_protein_xyz)\n\n        if self.fragment_set == None:\n            fragment_set = str(resources.files(__package__ + \".fragment\"))\n        else:\n            fragment_set = os.path.join(os.getcwd(),self.fragment_set)\n\n        if self.rollout_set == None:\n            rollout_set = str(resources.files(__package__ + \".rollout_fragment\"))\n        else:\n            rollout_set = os.path.join(os.getcwd(),self.rollout_set)\n\n        if self.desired_frag == None:\n            desired_frag_root = str(resources.files(__package__ + \"\"))\n        else:\n            desired_frag_root = os.path.join(os.getcwd(),self.desired_frag)\n\n        if self.desired_frag_rollout == None:\n            desired_frag_rollout_root = str(resources.files(__package__ + \"\"))\n        else:\n            desired_frag_rollout_root = os.path.join(os.getcwd(),self.desired_frag_rollout)\n\n        cycle = self.cycle\n        #desired_frag\u3092\u5165\u308c\u308bcycle\uff080\u306b\u3057\u3066\u306f\u3060\u3081,-1\u3060\u3068desired_fragment\u306f\u5165\u3089\u306a\u3044\uff09\n        des_frag_cycle = self.des_frag_cycle\n\n        if des_frag_cycle &gt;= 1:\n            desired_frag = [desired_frag_root]\n            desired_frag_rollout = [desired_frag_rollout_root]\n        else:\n            desired_frag = ['']\n            desired_frag_rollout = ['']\n\n        #clean_path = os.path.join(os.getcwd(), \"clean.sh\")\n        clean_path = os.path.join(resources.files(__package__),'clean.sh')\n\n        if self.clean == True:\n            subprocess.call([clean_path])\n        max_branch_core = self.max_branch_core\n\n        max_branch_frag = self.max_branch_frag\n        result_conf = self.result_conf\n\n        max_conf = self.max_conf\n\n        cutoff_score_init = self.cutoff_score_init\n        cutoff_score_fin = self.cutoff_score_fin\n\n        rollout_num = self.rollout_num\n\n        rollout_frag_max = self.rollout_frag_max\n\n        evaluation_param = self.evaluation_param\n\n        evaluation_method = self.evaluation_method\n\n        count_for_data_processing = self.count_for_data_processing\n\n        image_dir_name = self.image_dir_name\n        rollout_conf_inner = self.rollout_conf_inner\n        rollout_conf_inner_des = self.rollout_conf_inner_des\n\n        sigma_sum_cut = self.sigma_sum_cut\n\n        if os.path.isdir(result_dir):\n            shutil.rmtree(result_dir)\n\n        os.mkdir(result_dir)\n        image_dir = result_dir +'/' +image_dir_name\n        os.mkdir(image_dir)\n\n\n        if(os.path.isfile(logfile)):\n            os.remove(logfile)\n\n        if(os.path.isfile(paramlog)):\n            os.remove(paramlog)\n        logger=my_logfile(logfile,'INFO','a')\n        logger_notime=my_logfile_notime(logfile,'INFO_notime','a')\n        logger_state=my_logfile(paramlog,'Param','a')\n        logger_state_notime=my_logfile_notime(paramlog,'Param_notime','a')\n\n\n        logger.info('Execute LigX program')\n        logger_notime.info('\\nLigX: Ligand Extending Program for Medicinal Chemistry. (2025)')\n        logger_notime.info('\\nVersion: ' + str(__version__))\n\n        logger_state.info('Execute LigX program')\n        logger_state_notime.info('\\nLigX: Ligand Extending Program for Medicinal Chemistry. (2025)')\n        logger_state_notime.info('\\nVersion: ' + str(__version__))\n        logger_state_notime.info('\\nDetailed parameters will be written in this file.')\n\n        logger_state_notime.info('\\n################################LigXLigX###############################')\n\n        desired_list = []\n\n        if desired_frag != ['']:\n            for des in desired_frag:\n                if self.clean == True:\n                    subprocess.call([clean_path])\n                despath_list = os.listdir(des)\n                for i in despath_list:\n                    if i != 'charge.txt' and i != 'param.txt':\n                        desired_list.append(des+'/'+i)\n\n                    des_category = extract_des_category(des)\n\n        if desired_frag == ['']:\n            des_category = None\n\n        desired_list_rollout = []\n        if desired_frag_rollout != ['']:\n            for des in desired_frag_rollout:\n                if self.clean == True:\n                    subprocess.call([clean_path])\n                despath_list_rollout = os.listdir(des)\n                for i in despath_list_rollout:\n                    if i != 'charge.txt' and i != 'param.txt':\n                        desired_list_rollout.append(des+'/'+i)\n                    rol_des_category = extract_des_category(des)\n\n        if desired_frag_rollout == ['']:\n            rol_des_category = None\n\n        if self.clean == True:\n            subprocess.call([clean_path])\n        core_dir_list_root = os.listdir(dir_parent)\n\n        core_dir_list = [os.path.join(dir_parent,x) for x in core_dir_list_root]\n\n        protein_xyz_dir_list = os.listdir(dir_protein_xyz)\n        protein_xyz_dir_list.sort()\n\n        #Load protein structue\n        protein_index = 0\n        all_protein_cord = []\n        for protein_xyz_dir in protein_xyz_dir_list:\n            var_name = 'protein_cord_'+str(protein_index)\n            protein_path = os.path.join(dir_protein_xyz,protein_xyz_dir)\n            protein_cord,empty_name = read_xyz_data(protein_path)\n            exec(\"{} = protein_cord\".format(var_name))\n            all_protein_cord.append(protein_cord)\n            protein_index +=1\n\n        num_protein_structures = len(all_protein_cord)\n\n        count_generated = 0\n        try_num = 0\n\n        all_result = []\n\n        all_score_strategy_0 = ['ID']\n        time_init = 0\n\n        for i in range(num_protein_structures):\n            x = 'LJ['+str(i)+']'\n            all_score_strategy_0.append(x)\n        all_score_strategy_0.append('LJ_average')\n\n        for i in range(num_protein_structures):\n            x = 'coulomb['+str(i)+']'\n            all_score_strategy_0.append(x)\n        all_score_strategy_0.append('coulomb_average')\n\n        for i in range(num_protein_structures):\n            x = 'interact_E['+str(i)+']'\n            all_score_strategy_0.append(x)\n        all_score_strategy_0.append('interact_E_average')\n\n        for i in range(num_protein_structures):\n            x = 'LE_LJ['+str(i)+']'\n            all_score_strategy_0.append(x)\n        all_score_strategy_0.append('LE_LJ_average')\n\n        for i in range(num_protein_structures):\n            x = 'LE_interact_E['+str(i)+']'\n            all_score_strategy_0.append(x)\n        all_score_strategy_0.append('LE_interact_E_average')\n\n        for i in range(num_protein_structures):\n            x = 'LE_LJ+coulomb['+str(i)+']'\n            all_score_strategy_0.append(x)\n        all_score_strategy_0.append('LE_LJ+coulomb_average')\n        all_score_strategy_0.append('strategy')\n        all_score_strategy_0.append('SMILES')\n        all_score_strategy =[all_score_strategy_0]\n\n        transform_dict = get_transform_dict_hyd(fragment_set)\n\n        setting_info = sum_set_info(cycle,des_frag_cycle,max_branch_core,max_branch_frag,result_conf,max_conf,cutoff_score_init,cutoff_score_fin,rollout_num,rollout_frag_max,fragment_set,rollout_set,desired_frag,desired_frag_rollout,evaluation_param,evaluation_method,core_dir_list,protein_xyz_dir_list)\n\n        logger_notime.info('\\n################################ Setting Info ###############################\\n')\n        logger_notime.info(setting_info)\n        logger_notime.info('############################# Setting Info Ending ###########################\\n')\n\n\n        blue_print('Loading fragments\u2026')\n        logger_notime.info('Loading fragments\u2026')\n        logger_notime.info('\\n################################LigXLigX###############################')\n\n        #Initialization of Fragments\n\n        Frag_F1L = Fragments('F1L',transform_dict)\n        Frag_F2L = Fragments('F2L',transform_dict)\n        Frag_C1L = Fragments('C1L',transform_dict)\n        Frag_C2L = Fragments('C2L',transform_dict)\n        Frag_dict = {'F1L': Frag_F1L, 'F2L': Frag_F2L,'C1L': Frag_C1L, 'C2L': Frag_C2L}\n\n        if 'F3L' in os.listdir(fragment_set):\n            Frag_F3L = Fragments('F3L',transform_dict)\n            Frag_dict['F3L'] = Frag_F3L\n        if 'F2LB' in os.listdir(fragment_set):\n            Frag_F2LB = Fragments('F2LB',transform_dict)\n            Frag_dict['F2LB'] = Frag_F2LB\n        if 'C3L' in os.listdir(fragment_set):\n            Frag_C3L = Fragments('C3L',transform_dict)\n            Frag_dict['C3L'] = Frag_C3L\n        if 'XHD' in os.listdir(fragment_set):\n            Frag_XHD = Fragments('XHD',transform_dict)\n            Frag_dict['XHD'] = Frag_XHD\n        if 'XFO' in os.listdir(fragment_set):\n            Frag_XFO = Fragments('XFO',transform_dict)\n            Frag_dict['XFO'] = Frag_XFO\n\n        Frag_desired = desFragments(desired_list,des_category)\n        #Frag_dict = {'F1L': Frag_F1L, 'F2L': Frag_F2L, 'F3L': Frag_F3L, 'F2LB': Frag_F2LB, 'C1LB': Frag_C1LB, 'C1L': Frag_C1L, 'C2L': Frag_C2L, 'C3L': Frag_C3L,'XHD': Frag_XHD, 'XFO': Frag_XFO}\n        start = time.time()\n        logger_notime.info('Generating molecules\u2026')\n        logger_notime.info('\\n################################LigXLigX###############################')\n\n        count_for_top = 0\n        all_state = [['init',100,1]]\n\n        #Generation\n        while count_generated &lt; max_conf:\n            cutoff_score = cutoff_score_init + (count_generated*(cutoff_score_fin-cutoff_score_init)/(max_conf))\n\n            current_branch_core = 0\n            current_branch_frag = 0\n            current_cycle = 1\n            depth = 0\n\n            EOF_value = False\n            blue_print('Generating molecules\u2026')\n            while EOF_value == False:\n\n                if depth == 0:\n                    if self.clean == True:\n                        subprocess.call([clean_path])\n                    each_strategy = []\n                    infomation = 'Trying Sequence No.' +str(try_num+1)\n                    logger.info(infomation)\n\n                    for dir_core in core_dir_list:\n\n                        current_state = []\n                        initial_remaining_data,S,Q,P,total_charge,transform_log_main,transform_log_side,c_for_next,param_for_next,added_frag,ref_frag_list_next = import_core(dir_core)\n\n                        current_state.append(dir_core)\n\n                        state_for_rollout = current_state\n\n                        first_elements = [sublist[0] for sublist in all_state]\n                        add_cycle = 0\n                        core = Core_mol(initial_remaining_data,current_cycle,cycle,current_branch_core,current_branch_frag,max_branch_core,max_branch_frag,ref_frag_list_next,param_for_next,total_charge,transform_log_main,transform_log_side,c_for_next)\n                        Q_atom = core.Q_atom\n                        if not any(current_state == item for item in first_elements):\n\n                            if current_cycle != des_frag_cycle:\n\n                                all_atom = [x for i in core.operation for x in Frag_dict[i].atom]\n                                all_coord = [x for i in core.operation for x in Frag_dict[i].coord]\n                                all_charge = [x for i in core.operation for x in Frag_dict[i].charge]\n                                all_each_frag = [x for i in core.operation for x in Frag_dict[i].each_frag]\n                                all_len_list = [x for i in core.operation for x in Frag_dict[i].len_list]\n                                all_central_atom = [x for i in core.operation for x in Frag_dict[i].central_atom]\n                                all_category = [x for i in core.operation for x in Frag_dict[i].category]\n                                all_param = [x for i in core.operation for x in Frag_dict[i].param]\n                                all_frag = [x for i in core.operation for x in Frag_dict[i].frag_name]\n                                all_add_branch_core = [x for i in core.operation for x in Frag_dict[i].add_branch_core]\n                                all_add_branch_frag = [x for i in core.operation for x in Frag_dict[i].add_branch_frag]\n                                all_ref_frag_list = [x for i in core.operation for x in Frag_dict[i].ref_frag_list]\n                                split_ind_list_1,split_ind_list_2 = create_split_ind_list(all_len_list)\n                                possibility = True\n\n                            elif current_cycle == des_frag_cycle and any(x == Frag_desired.frag_category_val[0] for x in core.operation):\n                                all_atom = [x for x in Frag_desired.atom]\n                                all_coord = [x for x in Frag_desired.coord]\n                                all_charge = [x for x in Frag_desired.charge]\n                                all_each_frag = [x for x in Frag_desired.each_frag]\n                                all_len_list = [x for x in Frag_desired.len_list]\n                                all_central_atom = [x for x in Frag_desired.central_atom]\n                                all_category = [x for x in Frag_desired.category]\n                                all_param = [x for x in Frag_desired.param]\n                                all_frag = [x for x in Frag_desired.frag_name]\n                                all_add_branch_core = [x for x in Frag_desired.add_branch_core]\n                                all_add_branch_frag = [x for x in Frag_desired.add_branch_frag]\n                                all_ref_frag_list = [x for x in Frag_desired.ref_frag_list]\n                                split_ind_list_1,split_ind_list_2 = create_split_ind_list(all_len_list)\n                                possibility = True\n\n                            elif current_cycle == des_frag_cycle and not any(x == Frag_desired.frag_category_val[0] for x in core.operation):\n\n                                escape_state = deepcopy(to_frons_state)\n                                first_list = [sublist[0] for sublist in all_state]\n                                escape_ind= first_list.index(escape_state[0])\n                                all_state[escape_ind][1] = 100\n                                all_state[escape_ind][2] = 10000000\n                                possibility = False\n\n                            if possibility:\n                                score = execute_rollout_v2(initial_remaining_data,S,Q,P,total_charge,transform_log_main,transform_log_side,c_for_next,param_for_next,added_frag,ref_frag_list_next,current_cycle,cycle,current_branch_core,current_branch_frag,max_branch_core,max_branch_frag,evaluation_param,evaluation_method,desired_list_rollout,rollout_set,all_protein_cord,add_cycle,state_for_rollout,rol_des_category,des_frag_cycle,dir_core,cutoff_score_init,rollout_conf_inner,rollout_conf_inner_des,sigma_sum_cut)\n\n                                all_state.append([current_state,score,1])\n\n                    core_state = [item for item in all_state if len(item[0]) == 1]\n                    core_state = sorted(core_state, key=lambda x: (x[2],x[1]))\n                    selected_core_state = []\n                    for i in core_state:\n                        if i[1] &lt;= cutoff_score and i[2]&lt;10000000:\n                            selected_core_state.append(i)\n\n                    if selected_core_state ==[]:\n                        if count_generated == 0:\n\n                            print('no possibility in this core')\n                            logger.info('no possibility in this core')\n                            logger_notime.info('\\n################################LigXLigX###############################')\n                            sys.exit()\n                        else:\n                            print('the search is terminated because of no possibility.')\n                            logger.info('no possibility in this core')\n                            logger_notime.info('\\n################################LigXLigX###############################')\n                            max_conf = count_generated\n                            break\n\n                    else:\n                        ubc_ind = calc_UCB(selected_core_state,cutoff_score)\n                        core = selected_core_state[ubc_ind][0][0]\n\n                        initial_remaining_data,S,Q,P,total_charge,transform_log_main,transform_log_side,c_for_next,param_for_next,added_frag,ref_frag_list_next = import_core(dir_core)\n                        core = Core_mol(initial_remaining_data,current_cycle,cycle,current_branch_core,current_branch_frag,max_branch_core,max_branch_frag,ref_frag_list_next,param_for_next,total_charge,transform_log_main,transform_log_side,c_for_next)\n\n\n                        first_list = [sublist[0] for sublist in all_state]\n\n                        ind= first_list.index(selected_core_state[ubc_ind][0])\n\n                        all_state[ind][2] +=1\n\n                        depth = 1\n                        next_state = selected_core_state[ubc_ind]\n\n\n                #depth != 0\n                else:\n                    temp_current_state = []\n\n\n\n\n                    to_frons_state = next_state\n\n                    temp_state = next_state\n\n                    current_state = []\n\n                    if current_cycle != des_frag_cycle:\n                        #\u305d\u306e\u6642\u70b9\u3067\u9023\u7d50\u53ef\u80fd\u306a\u3059\u3079\u3066\u306e\u30d5\u30e9\u30b0\u30e1\u30f3\u30c8\u3092\u51e6\u7406\n                        all_atom = [x for i in core.operation for x in Frag_dict[i].atom]\n                        all_coord = [x for i in core.operation for x in Frag_dict[i].coord]\n                        all_charge = [x for i in core.operation for x in Frag_dict[i].charge]\n                        all_each_frag = [x for i in core.operation for x in Frag_dict[i].each_frag]\n                        all_len_list = [x for i in core.operation for x in Frag_dict[i].len_list]\n                        all_central_atom = [x for i in core.operation for x in Frag_dict[i].central_atom]\n                        all_category = [x for i in core.operation for x in Frag_dict[i].category]\n                        all_param = [x for i in core.operation for x in Frag_dict[i].param]\n                        all_frag = [x for i in core.operation for x in Frag_dict[i].frag_name]\n                        all_add_branch_core = [x for i in core.operation for x in Frag_dict[i].add_branch_core]\n                        all_add_branch_frag = [x for i in core.operation for x in Frag_dict[i].add_branch_frag]\n                        all_ref_frag_list = [x for i in core.operation for x in Frag_dict[i].ref_frag_list]\n                        all_frag_category_val = [x for i in core.operation for x in Frag_dict[i].frag_category_val]\n                        split_ind_list_1,split_ind_list_2 = create_split_ind_list(all_len_list)\n                        frag_c_for_next = [x for i in core.operation for x in Frag_dict[i].c_for_next]\n                        possibility = True\n                        desired_check = False\n\n\n                    elif current_cycle == des_frag_cycle and any(x == Frag_desired.frag_category_val[0] for x in core.operation):\n\n                        all_atom = [x for x in Frag_desired.atom]\n                        all_coord = [x for x in Frag_desired.coord]\n                        all_charge = [x for x in Frag_desired.charge]\n                        all_each_frag = [x for x in Frag_desired.each_frag]\n                        all_len_list = [x for x in Frag_desired.len_list]\n                        all_central_atom = [x for x in Frag_desired.central_atom]\n                        all_category = [x for x in Frag_desired.category]\n                        all_param = [x for x in Frag_desired.param]\n                        all_frag = [x for x in Frag_desired.frag_name]\n                        all_add_branch_core = [x for x in Frag_desired.add_branch_core]\n                        all_add_branch_frag = [x for x in Frag_desired.add_branch_frag]\n                        all_ref_frag_list = [x for x in Frag_desired.ref_frag_list]\n                        all_frag_category_val = [x for x in Frag_desired.frag_category_val]\n                        all_frag_category_val = [x for x in Frag_desired.frag_category_val]\n                        frag_c_for_next = [x for x in Frag_desired.c_for_next]\n                        split_ind_list_1,split_ind_list_2 = create_split_ind_list(all_len_list)\n                        possibility = True\n                        desired_check = True\n\n\n                    elif current_cycle == des_frag_cycle and not any(x == Frag_desired.frag_category_val[0] for x in core.operation):\n                        escape_state = deepcopy(to_frons_state)\n                        first_list = [sublist[0] for sublist in all_state]\n                        escape_ind= first_list.index(escape_state[0])\n                        all_state[escape_ind][1] = 100\n                        all_state[escape_ind][2] = 10000000\n                        possibility = False\n                        depth = 0\n\n                    if possibility:\n\n                        temp_state_0 = temp_state[0]\n                        first_elements_for_check = [sublist[0] for sublist in all_state if len(sublist[0])==(len(temp_state_0)+1) and sublist[0][:len(temp_state_0)]== temp_state_0]\n\n\n                        int_result = link_result(core,all_atom,all_coord,all_charge,all_central_atom,split_ind_list_1,split_ind_list_2,all_category,all_param,all_len_list,all_frag,all_protein_cord,evaluation_param,evaluation_method,all_ref_frag_list,frag_c_for_next,sigma_sum_cut)\n                        if first_elements_for_check == []:\n\n                            int_result_list = int_result.evaluation.tolist()\n                            current_state_0 = [[a,b,2] for a,b in zip(all_each_frag,int_result_list)]\n                            current_state = deepcopy(current_state_0)\n                            sorted_current_state = sorted(current_state, key=lambda x: (x[2],x[1]))\n                            sorted_current_state_list = [sublist[1] for sublist in sorted_current_state if sublist[1] &lt;= 0]\n                            sorted_current_state_frag_dir = [sublist[0][0].split('/')[-2] for sublist in sorted_current_state if sublist[1] &lt;= 0]\n                            if desired_check == False:\n                                if len(sorted_current_state_list) &gt;= rollout_num:\n                                    new_sorted_current_state_list = []\n                                    frag_count_list = []\n                                    x = 0\n                                    for s,f in zip(sorted_current_state_list,sorted_current_state_frag_dir):\n                                        if not any(f == a[0] for a in frag_count_list):\n                                            frag_count_list.append([f,1])\n                                            new_sorted_current_state_list.append(s)\n                                            x += 1\n                                            if x &gt;= rollout_num:\n                                                break\n\n                                        else:\n                                            index_frag = [a[0] for a in frag_count_list].index(f)\n                                            if frag_count_list[index_frag][1] &lt;= rollout_frag_max:\n                                                frag_count_list[index_frag][1] += 1\n                                                new_sorted_current_state_list.append(s)\n                                                x += 1\n                                                if x &gt;= rollout_num:\n                                                    break\n                                            else:\n                                                frag_count_list[index_frag][1] += 1\n\n                                    sorted_current_state_list = new_sorted_current_state_list\n\n                            #Manipulation of each fragment\n                            for i in range(len(sorted_current_state_list)):\n\n                                best_index = current_state.index(sorted_current_state[i])\n\n\n                                next_frag_atom = int_result.atom[split_ind_list_1[best_index]:split_ind_list_2[best_index]]\n                                next_frag_coord = int_result.coord[split_ind_list_1[best_index]:split_ind_list_2[best_index]]\n                                EOF_value = int_result.eof_val[best_index]\n                                category = int_result.temp_category[best_index]\n                                temp_frag = int_result.temp_frag[best_index]\n                                ref_frag_list_next = int_result.ref_frag_list_next_list[best_index]\n\n                                first_list = [sublist[0] for sublist in all_state]\n\n                                new_core_structure = create_new_core_structure(core,next_frag_atom,next_frag_coord,category,temp_frag,ref_frag_list_next)\n\n                                current_cycle = core.add_cycle+core.current_cycle\n                                current_branch_core = core.current_branch_core + all_add_branch_core[best_index]\n                                current_branch_frag = core.current_branch_frag + all_add_branch_frag[best_index]\n                                ref_frag_list_next = int_result.ref_frag_list_next_list[best_index]\n                                param_for_next = int_result.param_for_next[best_index]\n                                total_charge = int_result.total_charge[best_index]\n                                transform_log_main = int_result.transform_log_main_list[best_index]\n                                transform_log_side = int_result.transform_log_side_list[best_index]\n\n                                if int_result.temp_frag[best_index] != 'sym24_XHD_0' and int_result.temp_frag[best_index] != 'sym24_XHD_1' and int_result.temp_frag[best_index] != 'sym24_XHD_2' and int_result.temp_frag[best_index] != 'sym24_XHD_3' and int_result.temp_frag[best_index] != 'sym24_XHD_4':\n                                    c_for_next = int_result.c_for_next_list[best_index]\n                                else:\n                                    c_for_next = ['XCA_1']\n\n                                if all_frag_category_val[best_index] != 'F1L' and all_frag_category_val[best_index] != 'C1L':\n\n                                    score = execute_rollout_v2(new_core_structure,S,Q,P,total_charge,transform_log_main,transform_log_side,c_for_next,param_for_next,added_frag,ref_frag_list_next,current_cycle,cycle,current_branch_core,current_branch_frag,max_branch_core,max_branch_frag,evaluation_param,evaluation_method,desired_list_rollout,rollout_set,all_protein_cord,add_cycle,state_for_rollout,rol_des_category,des_frag_cycle,dir_core,cutoff_score_init,rollout_conf_inner,rollout_conf_inner_des,sigma_sum_cut)\n                                else:\n                                    score = current_state[best_index][1]\n\n                                current_state[best_index][1] = score\n                                current_state[best_index][2] = 1\n\n                            each_state_0 = [[[next_state[0][0],sublist[0]]] + sublist[1:] if depth == 0 else [next_state[0]+[sublist[0]]] + sublist[1:] for sublist in current_state]\n                            each_state = deepcopy(each_state_0)\n                            ubc_ind = calc_UCB(current_state,cutoff_score)\n                            best_for_opt = deepcopy(each_state[ubc_ind])\n                            current_branch_core = core.current_branch_core + all_add_branch_core[ubc_ind]\n                            current_branch_frag = core.current_branch_frag + all_add_branch_frag[ubc_ind]\n                            ref_frag_list_next = int_result.ref_frag_list_next_list[ubc_ind]\n                            param_for_next = int_result.param_for_next[ubc_ind]\n                            total_charge = int_result.total_charge[ubc_ind]\n                            transform_log_main = int_result.transform_log_main_list[ubc_ind]\n                            transform_log_side = int_result.transform_log_side_list[ubc_ind]\n\n                            if int_result.temp_frag[ubc_ind] != 'sym24_XHD_0' and int_result.temp_frag[ubc_ind] != 'sym24_XHD_1' and int_result.temp_frag[ubc_ind] != 'sym24_XHD_2' and int_result.temp_frag[ubc_ind] != 'sym24_XHD_3' and int_result.temp_frag[ubc_ind] != 'sym24_XHD_4':\n                                c_for_next = int_result.c_for_next_list[ubc_ind]\n                            else:\n                                c_for_next = ['XCA_1']\n\n                            if int_result.temp_frag[ubc_ind] != 'sym24_XHD_0' and int_result.temp_frag[ubc_ind] != 'sym24_XHD_1' and int_result.temp_frag[ubc_ind] != 'sym24_XHD_2' and int_result.temp_frag[ubc_ind] != 'sym24_XHD_3' and int_result.temp_frag[ubc_ind] != 'sym24_XHD_4':\n\n                                for_opt_state = [best_for_opt]\n\n                                plus_15_deg_frag = deepcopy(best_for_opt)\n                                plus_15_deg_frag[0][-1][2] += 10\n                                for_opt_state.append(plus_15_deg_frag)\n\n\n                                minus_15_deg_frag = deepcopy(best_for_opt)\n                                minus_15_deg_frag[0][-1][2] -= 10\n                                for_opt_state.append(minus_15_deg_frag)\n\n                                for_opt_score = []\n\n                                for i in range(len(for_opt_state)):\n\n                                    transforming_core_point_int = create_structure_from_strategy(for_opt_state,i,cycle,max_branch_core,max_branch_frag)\n                                    if all_frag_category_val[ubc_ind] != 'F1L' and all_frag_category_val[ubc_ind] != 'C1L':\n                                        score = execute_rollout_v2(transforming_core_point_int,S,Q,P,total_charge,transform_log_main,transform_log_side,c_for_next,param_for_next,added_frag,ref_frag_list_next,current_cycle,cycle,current_branch_core,current_branch_frag,max_branch_core,max_branch_frag,evaluation_param,evaluation_method,desired_list_rollout,rollout_set,all_protein_cord,add_cycle,state_for_rollout,rol_des_category,des_frag_cycle,dir_core,cutoff_score_init,rollout_conf_inner,rollout_conf_inner_des,sigma_sum_cut)\n                                    else:\n                                        atom_list = [x[0] for x in transforming_core_point_int]\n                                        transforming_core_point_int_2= transforming_core_point_int[atom_list.index(core.Q_atom)+1:]\n                                        LJ_array_sum,coulomb_array_sum,int_E_array_sum = calc_interaction_from_strategy(transforming_core_point_int_2,all_protein_cord)\n                                        heavy_atom_list = [calc_heavy_atoms(transforming_core_point_int_2)]\n                                        score = calc_evaluation_v2(LJ_array_sum,coulomb_array_sum,int_E_array_sum,evaluation_param,evaluation_method,heavy_atom_list)[0]\n\n                                    for_opt_score.append(score)\n\n                                opt_index = for_opt_score.index(min(for_opt_score))\n                                each_state[ubc_ind][0][-1][2] = for_opt_state[opt_index][0][-1][2]\n                                each_state[ubc_ind][1] = for_opt_score[opt_index]\n                                current_state[ubc_ind][0][2] = for_opt_state[opt_index][0][-1][2]\n                                current_state[ubc_ind][1] = for_opt_score[opt_index]\n\n                        else:\n                            int_state = [sublist for sublist in all_state if len(sublist[0])==(len(temp_state_0)+1) and sublist[0][:len(temp_state_0)]== temp_state_0]\n                            current_state = [[a[0][-1],a[1],a[2]] for a in int_state]\n                            each_state = [[[next_state[0][0],sublist[0]]] + sublist[1:] if depth == 0 else [next_state[0]+[sublist[0]]] + sublist[1:] for sublist in current_state]\n\n                        current_score = [sublist[1] for sublist in current_state]\n                        current_selection = [sublist[2] for sublist in current_state]\n                        ubc_ind = calc_UCB(current_state,cutoff_score)\n\n\n                        if current_score[ubc_ind] &lt;= cutoff_score and current_selection[ubc_ind] &lt; 10000:\n\n                            #Update initiator\n                            if first_elements_for_check == []:\n                                all_state.extend(each_state)\n                            first_list = [sublist[0] for sublist in all_state]\n                            all_state_ind = first_list.index(next_state[0]+[current_state[ubc_ind][0]])\n\n                            EOF_value = int_result.eof_val[ubc_ind]\n                            next_frag_atom = int_result.atom[split_ind_list_1[ubc_ind]:split_ind_list_2[ubc_ind]]\n                            next_frag_coord = int_result.coord[split_ind_list_1[ubc_ind]:split_ind_list_2[ubc_ind]]\n                            category = int_result.temp_category[ubc_ind]\n                            temp_frag = int_result.temp_frag[ubc_ind]\n                            ref_frag_list_next = int_result.ref_frag_list_next_list[ubc_ind]\n                            current_branch_core = core.current_branch_core + all_add_branch_core[ubc_ind]\n                            current_branch_frag = core.current_branch_frag + all_add_branch_frag[ubc_ind]\n                            ref_frag_list_next = int_result.ref_frag_list_next_list[ubc_ind]\n                            param_for_next = int_result.param_for_next[ubc_ind]\n                            total_charge = int_result.total_charge[ubc_ind]\n                            transform_log_main = int_result.transform_log_main_list[ubc_ind]\n                            transform_log_side = int_result.transform_log_side_list[ubc_ind]\n\n                            if int_result.temp_frag[ubc_ind] != 'sym24_XHD_0' and int_result.temp_frag[ubc_ind] != 'sym24_XHD_1' and int_result.temp_frag[ubc_ind] != 'sym24_XHD_2' and int_result.temp_frag[ubc_ind] != 'sym24_XHD_3' and int_result.temp_frag[ubc_ind] != 'sym24_XHD_4':\n                                c_for_next = int_result.c_for_next_list[ubc_ind]\n                            else:\n                                c_for_next = ['XCA_1']\n\n                            core_name = each_state[ubc_ind][0][0]\n                            frag_angle = each_state[ubc_ind][0][-1][-2]\n                            score_info = \"{:.2f}\".format(current_score[ubc_ind])\n\n                            infomation = '\\tcore: '+str(core_name)+', depth: '+str(depth)+', fragment: '+str(temp_frag)+', dihedral: '+str(frag_angle)+', score: '+str(score_info)\n                            logger_notime.info(infomation)\n\n                            transforming_core_point_int = create_structure_from_strategy(each_state,ubc_ind,cycle,max_branch_core,max_branch_frag)\n\n                            if EOF_value == False:\n                                score = execute_rollout_v2(transforming_core_point_int,S,Q,P,total_charge,transform_log_main,transform_log_side,c_for_next,param_for_next,added_frag,ref_frag_list_next,current_cycle,cycle,current_branch_core,current_branch_frag,max_branch_core,max_branch_frag,evaluation_param,evaluation_method,desired_list_rollout,rollout_set,all_protein_cord,add_cycle,state_for_rollout,rol_des_category,des_frag_cycle,dir_core,cutoff_score_init,rollout_conf_inner,rollout_conf_inner_des,sigma_sum_cut)\n                            elif EOF_value == True:\n                                atom_list = [x[0] for x in transforming_core_point_int]\n                                transforming_core_point_int_2= transforming_core_point_int[atom_list.index(core.Q_atom)+1:]\n                                LJ_array_sum,coulomb_array_sum,int_E_array_sum = calc_interaction_from_strategy(transforming_core_point_int_2,all_protein_cord)\n                                heavy_atom_list = [calc_heavy_atoms(transforming_core_point_int_2)]\n                                score = calc_evaluation_v2(LJ_array_sum,coulomb_array_sum,int_E_array_sum,evaluation_param,evaluation_method,heavy_atom_list)[0]\n\n                            if EOF_value == False:\n                                all_state[all_state_ind][2] +=1\n                                depth += 1\n                                next_state = all_state[all_state_ind]\n\n                                category = int_result.temp_category[ubc_ind]\n                                temp_frag = int_result.temp_frag[ubc_ind]\n                                ref_frag_list_next = int_result.ref_frag_list_next_list[ubc_ind]\n                                current_cycle = core.add_cycle+core.current_cycle\n                                current_branch_core = core.current_branch_core + all_add_branch_core[ubc_ind]\n                                current_branch_frag = core.current_branch_frag + all_add_branch_frag[ubc_ind]\n                                ref_frag_list_next = int_result.ref_frag_list_next_list[ubc_ind]\n                                param_for_next = int_result.param_for_next[ubc_ind]\n                                total_charge = int_result.total_charge[ubc_ind]\n                                transform_log_main = int_result.transform_log_main_list[ubc_ind]\n\n                                transform_log_side = int_result.transform_log_side_list[ubc_ind]\n\n                                if int_result.temp_frag[ubc_ind] != 'sym24_XHD_0' and int_result.temp_frag[ubc_ind] != 'sym24_XHD_1' and int_result.temp_frag[ubc_ind] != 'sym24_XHD_2' and int_result.temp_frag[ubc_ind] != 'sym24_XHD_3' and int_result.temp_frag[ubc_ind] != 'sym24_XHD_4':\n                                    c_for_next = int_result.c_for_next_list[ubc_ind]\n\n                                else:\n                                    c_for_next = ['XCA_1']\n\n                                core = Core_mol(transforming_core_point_int,current_cycle,cycle,current_branch_core,current_branch_frag,max_branch_core,max_branch_frag,ref_frag_list_next,param_for_next,total_charge,transform_log_main,transform_log_side,c_for_next)\n\n                                infomation_for_param = '#LigX# @Sequence No.' +str(try_num+1)\n                                logger_state.info(infomation_for_param)\n                                param_log = param_for_logfile(transforming_core_point_int,current_cycle,current_branch_core,current_branch_frag,ref_frag_list_next,param_for_next,total_charge,transform_log_main,transform_log_side,c_for_next,temp_frag,next_frag_atom)\n                                logger_state_notime.info('')\n                                logger_state_notime.info(param_log)\n\n                                logger_state_notime.info('\\n################################LigXLigX###############################')\n\n                            elif EOF_value == True:\n                                infomation_for_param = '#LigX# @Sequence No.' +str(try_num+1)\n                                logger_state.info(infomation_for_param)\n                                param_log = param_for_logfile(transforming_core_point_int,current_cycle,current_branch_core,current_branch_frag,ref_frag_list_next,param_for_next,total_charge,transform_log_main,transform_log_side,c_for_next,temp_frag,next_frag_atom)\n                                logger_state.info('')\n                                logger_state_notime.info(param_log)\n                                logger_state_notime.info('\\n#LigX# EOF_value == True')\n\n\n                                logger_state_notime.info('\\n################################LigXLigX###############################')\n                                logger_state_notime.info('################################LigXLigX###############################')\n                                logger_state_notime.info('################################LigXLigX###############################')\n\n                                count_generated +=1\n                                try_num +=1\n                                all_state[all_state_ind][2] +=10000\n                                created = True\n\n                        else:\n                            first_list_to_escape = [sublist[0] for sublist in all_state]\n\n                            escape_ind = first_list_to_escape.index(temp_state_0)\n                            all_state[escape_ind][1] = 100\n                            all_state[escape_ind][2] = 10000\n                            depth = 0\n                            try_num +=1\n                            created = False\n\n                            green_print('Not generated in this sequence. Node pruning')\n\n                            logger_notime.info('Not generated in this sequence. Removed by cutoff')\n                            state_for_logfile = '\\tstate:'+str(each_state[ubc_ind])\n                            logger_notime.info('')\n                            logger_notime.info(state_for_logfile)\n                            logger_notime.info('\\n################################LigXLigX###############################')\n\n                            break\n\n                    elif possibility == False:\n                        temp_state_0 = temp_state[0]\n                        first_list_to_escape = [sublist[0] for sublist in all_state]\n\n                        escape_ind = first_list_to_escape.index(temp_state_0)\n                        all_state[escape_ind][1] = 100\n                        all_state[escape_ind][2] = 10000\n                        depth = 0\n                        green_print('Not generated in this sequence. Possibility: False. Node pruning')\n\n                        logger_notime.info('Not generated in this sequence. Possibility: False')\n                        logger_notime.info('\\n################################LigXLigX###############################')\n                        try_num +=1\n                        created = False\n                        break\n\n            #Save Data\n            if created == False:\n                continue\n            depth = 0\n\n\n\n\n            transforming_core_point_int = create_structure_from_strategy(each_state,ubc_ind,cycle,max_branch_core,max_branch_frag)\n            LJ_list = [x[0] for x in LJ_array_sum]\n            coulomb_list = [x[0] for x in coulomb_array_sum]\n            int_E_list = [x[0] for x in int_E_array_sum]\n            heavy_atom = heavy_atom_list[0]\n            if heavy_atom == 0:\n                heavy_atom = 1\n\n            LE_LJ =[float(x)/int(heavy_atom) for x in LJ_list]\n            LE_LJ_coulomb = []\n            for a,b in zip(LE_LJ,coulomb_list):\n                LE_LJ_coulomb.append(a+float(b))\n\n            transforming_core_point =atomname_change_final(transforming_core_point_int)\n            final_total_atom = [str(int(len(transforming_core_point)))]\n            each_name = ['ID_'+str(count_generated)]\n            temp_structure = []\n\n            temp_structure.append(final_total_atom)\n            temp_structure.append(each_name)\n\n            for j in transforming_core_point:\n                float_point =[round(value.item(), 4) if isinstance(value, np.float64) else value for value in j]\n                temp_structure.append(float_point)\n\n            smiles = get_smiles(temp_structure,total_charge,self.smiles_filter)\n\n            if smiles != 'no_SMILES' and current_cycle-1 &gt;= des_frag_cycle:\n\n                all_result.append(final_total_atom)\n                all_result.append(each_name)\n\n                for j in transforming_core_point:\n                    float_point =[round(value.item(), 4) if isinstance(value, np.float64) else value for value in j]\n                    all_result.append(float_point)\n\n                all_result_name = 'result_all_total_conf_'+str(count_generated)\n                save_csv(all_result,all_result_name,result_dir)\n                if count_generated &gt;1:\n                    remove_file = result_dir+'/result_all_total_conf_'+str(count_generated-1)+'.xyz'\n                    os.remove(remove_file)\n\n                each_result = [count_generated]\n\n                for i in range(num_protein_structures):\n                    each_result.append(LJ_list[i])\n\n                LJ_average = statistics.mean(LJ_list)\n                each_result.append(LJ_average)\n\n                for i in range(num_protein_structures):\n                    each_result.append(coulomb_list[i])\n                coulomb_average = statistics.mean(coulomb_list)\n                each_result.append(coulomb_average)\n\n                for i in range(num_protein_structures):\n                    each_result.append(int_E_list[i])\n                int_E_average = statistics.mean(int_E_list)\n                each_result.append(int_E_average)\n\n                for i in range(num_protein_structures):\n                    each_result.append(float(LJ_list[i])/int(heavy_atom))\n                LJ_LE_average = statistics.mean(LJ_list)/int(heavy_atom)\n                each_result.append(LJ_LE_average)\n\n                for i in range(num_protein_structures):\n                    each_result.append(float(int_E_list[i])/int(heavy_atom))\n                int_E_LE_average = statistics.mean(int_E_list)/int(heavy_atom)\n                each_result.append(int_E_LE_average)\n\n                for i in range(num_protein_structures):\n                    each_result.append(LE_LJ_coulomb[i])\n\n                LE_LJ_coulomb_LJ_average = statistics.mean(LE_LJ_coulomb)\n                each_result.append(LE_LJ_coulomb_LJ_average)\n\n                each_result.append(each_state[ubc_ind])\n                each_result.append(smiles)\n\n                all_score_strategy.append(each_result)\n\n                score_name = 'result_score'\n                save_csv_2(all_score_strategy,score_name,result_dir)\n\n                score_for_info =  \"{:.3f}\".format(score)\n                generated_time = time.time()\n\n                elapsed_time = generated_time-start\n\n                performance = calc_performance(count_generated,elapsed_time)\n\n                generated_info = '#LigX# '+str(count_generated)+' conf generated (' +performance +'), score = '+str(score_for_info)\n\n                red_print(generated_info)\n\n                structure_info = '\\tName: '+str(each_name[0])+', SMILES: '+str(smiles)\n                state_for_logfile = '\\tstate:'+str(each_state[ubc_ind])\n                logger_notime.info('')\n                logger_notime.info(state_for_logfile)\n                logger_notime.info('')\n                logger.info(generated_info)\n                logger_notime.info(structure_info)\n                logger_notime.info('\\n################################LigXLigX###############################')\n\n                if smiles != 'without_SMILES_conversion':\n                    for_fig = Chem.MolFromSmiles(smiles)\n                    Draw.MolToFile(for_fig,image_dir+'/'+str(each_name[0])+'.png',size=(900, 900))\n\n            else:\n                green_print('Removed by SMILES filter')\n                state_for_logfile = '\\tstate:'+str(each_state[ubc_ind])\n                logger_notime.info('')\n                logger_notime.info(state_for_logfile)\n                logger_notime.info('Removed by SMILES filter')\n                logger_notime.info('\\n################################LigXLigX###############################')\n                count_generated-=1\n\n            if (count_generated)//count_for_data_processing &gt; (count_generated-1)//count_for_data_processing and smiles != 'no_SMILES':\n\n\n                if os.path.isdir(result_dir+'/result_conf_'+str(count_for_top)):\n                    shutil.rmtree(result_dir+'/result_conf_'+str(count_for_top))\n                    del count_for_top\n\n                count_for_top = deepcopy(count_generated)\n\n                print('creating top at conf '+ str(count_for_top))\n                os.mkdir(result_dir+'/result_conf_'+str(count_for_top))\n                index_list = get_reconstract_strategy(num_protein_structures,all_score_strategy)\n                all_score_strategy_cut = all_score_strategy[1:]\n                if self.clean == True:\n                    subprocess.call([clean_path])\n\n\n                for index_name,index in index_list[1:-1]:\n                    sorted_all_score_strategy_cut = sorted(all_score_strategy_cut, key=lambda x: x[index])\n                    count_sel = 0\n                    ranking_list = []\n                    each_ranking_dir = result_dir+'/result_conf_'+str(count_generated)+'/'+index_name\n                    os.mkdir(each_ranking_dir)\n\n                    for sorted_list in sorted_all_score_strategy_cut:\n\n                        count_sel += 1\n                        if count_sel &gt;result_conf:\n                            break\n                        depth = 0\n                        ID_for_reult =sorted_list[0]\n\n                        each_strategy = sorted_list[-2]\n                        each_strategy_fin = [each_strategy]\n\n                        final_charge = get_core_charge(each_strategy_fin[0][0][0])\n\n\n                        for i in each_strategy_fin[0][0][1:]:\n                            final_charge += int(i[-1])\n                            #print(i[-1])\n\n                        transforming_core_point = create_structure_from_strategy(each_strategy_fin,0,cycle,max_branch_core,max_branch_frag)\n\n                        transforming_core_point =atomname_change_final(transforming_core_point)\n                        final_total_atom = [str(int(len(transforming_core_point)))]\n                        rank_num = str(count_sel).zfill(4)\n                        each_name = ['rank_'+rank_num+'_'+index_name+'_ID_'+str(ID_for_reult)]\n\n                        each_list = []\n\n                        each_list.append(final_total_atom)\n                        each_list.append(each_name)\n                        ranking_list.append(final_total_atom)\n                        ranking_list.append(each_name)\n\n                        for j in transforming_core_point:\n                            float_point =[round(value.item(), 4) if isinstance(value, np.float64) else value for value in j]\n                            each_list.append(float_point)\n                            ranking_list.append(float_point)\n\n                        each_result ='result_conf_'+str(count_generated)+'/'+index_name+'/'+str(each_name[0])+'/'+str(each_name[0])\n                        os.mkdir(each_ranking_dir+'/'+str(each_name[0]))\n                        dir_charge = each_ranking_dir+'/'+str(each_name[0])\n\n                        save_csv(each_list,each_result,result_dir)\n                        save_charge(final_charge,dir_charge)\n                    result_name ='result_conf_'+str(count_generated)+'/'+'ranking_'+index_name+'_top'\n                    save_csv(ranking_list,result_name,result_dir)\n\n\n        if os.path.isdir(result_dir+'/result_conf_'+str(count_for_top)):\n            shutil.rmtree(result_dir+'/result_conf_'+str(count_for_top))\n            del count_for_top\n\n        count_for_top = deepcopy(count_generated)\n\n        print('creating top at conf '+ str(count_generated))\n        os.mkdir(result_dir+'/result_conf_'+str(count_generated))\n        index_list = get_reconstract_strategy(num_protein_structures,all_score_strategy)\n        all_score_strategy_cut = all_score_strategy[1:]\n        if self.clean == True:\n            subprocess.call([clean_path])\n\n        for index_name,index in index_list[1:-1]:\n            sorted_all_score_strategy_cut = sorted(all_score_strategy_cut, key=lambda x: x[index])\n            count_sel = 0\n            ranking_list = []\n            each_ranking_dir = result_dir+'/result_conf_'+str(count_generated)+'/'+index_name\n            os.mkdir(each_ranking_dir)\n\n            for sorted_list in sorted_all_score_strategy_cut:\n\n                count_sel += 1\n                if count_sel &gt;result_conf:\n                    break\n                depth = 0\n                ID_for_reult =sorted_list[0]\n\n                each_strategy = sorted_list[-2]\n                each_strategy_fin = [each_strategy]\n\n                final_charge = get_core_charge(each_strategy_fin[0][0][0])\n\n                for i in each_strategy_fin[0][0][1:]:\n                    final_charge += int(i[-1])\n\n                transforming_core_point = create_structure_from_strategy(each_strategy_fin,0,cycle,max_branch_core,max_branch_frag)\n\n                transforming_core_point =atomname_change_final(transforming_core_point)\n                final_total_atom = [str(int(len(transforming_core_point)))]\n                rank_num = str(count_sel).zfill(4)\n                each_name = ['rank_'+rank_num+'_'+index_name+'_ID_'+str(ID_for_reult)]\n\n                each_list = []\n\n                each_list.append(final_total_atom)\n                each_list.append(each_name)\n                ranking_list.append(final_total_atom)\n                ranking_list.append(each_name)\n\n                for j in transforming_core_point:\n                    float_point =[round(value.item(), 4) if isinstance(value, np.float64) else value for value in j]\n                    each_list.append(float_point)\n                    ranking_list.append(float_point)\n\n                each_result ='result_conf_'+str(count_generated)+'/'+index_name+'/'+str(each_name[0])+'/'+str(each_name[0])\n                os.mkdir(each_ranking_dir+'/'+str(each_name[0]))\n                dir_charge = each_ranking_dir+'/'+str(each_name[0])\n\n                save_csv(each_list,each_result,result_dir)\n                save_charge(final_charge,dir_charge)\n            result_name ='result_conf_'+str(count_generated)+'/'+'ranking_'+index_name+'_top'\n            save_csv(ranking_list,result_name,result_dir)\n        print('Normal termination')\n        logger.info('Normal termination')\n        logger_notime.info('\\n################################LigXLigX###############################')\n</code></pre>"},{"location":"user_fragment/","title":"Using User-Specified Fragments","text":""},{"location":"user_fragment/#additional-fragment-set","title":"Additional fragment set","text":"<p>Your can obtain additional fragments that can be used in LigX from the Github repository (akatsuyama/LigX-data).</p> <p>Each fragment dataset (an xyz file and two txt files) is stored in a directory, categorized as either C2L or F2L. Both fragment types have two connectors. In the case of C2L fragments, the SC connector is the one that binds to the initiator. In contrast, F2L fragments bind to the initiator through the FC connector.</p> <p>Place any user-specified fragment directories into either the C2L or F2L directory, depending on their category, following the layout shown below.</p> <p>The following is an example layout when using six fragments: xxx, yyy, zzz, aaa, bbb, and ccc.</p> <pre>\nwork_dir/\n\u251c\u2500\u2500 run_ligx.py\n\u251c\u2500\u2500 .\n\u251c\u2500\u2500 .\n\u2514\u2500\u2500 external_fragment/\n    \u251c\u2500\u2500 C1L\n    \u251c\u2500\u2500 C2L/\n    \u2502   \u251c\u2500\u2500 xxx/        #obtained fragment (directory)\n    \u2502   \u251c\u2500\u2500 yyy/        #obtained fragment (directory)\n    \u2502   \u2514\u2500\u2500 zzz/        #obtained fragment (directory)\n    \u251c\u2500\u2500 F1L\n    \u2514\u2500\u2500 F2L/\n        \u251c\u2500\u2500 aaa/        #obtained fragment (directory)\n        \u251c\u2500\u2500 bbb/        #obtained fragment (directory)\n        \u2514\u2500\u2500 ccc/        #obtained fragment (directory)\n\n</pre> <p>An external_fragment directory containing empty C2L and F2L subfolders can be downloaded from the GitHub repository. Other directories, such as C1L, may already contain required data set. It is recommended to use this template when organizing your custom fragments according to their respective categories.</p> <p>Note: When an external fragment set is specified, the default fragment set normally loaded by LigX will not be included. This means that if you want to add fragments, you must combine your additional fragments with those from the default set. The default fragment set can be obtained from the GitHub repository (akatsuyama/LigX-data).</p>"},{"location":"user_fragment/#default-fragment-set-in-ligx","title":"Default fragment set in LigX","text":"<p>The following fragment set is used by default.</p>"},{"location":"user_fragment/#default-fragment-set","title":"Default fragment set","text":"<ul> <li>C2L fragments</li> </ul> fragment name chemical structure B1L_0000 (SC) hydrogen (SC) C2L_0001 para-phenyl (SC to SC) C2L_0002 ethylene C2L_0003 methylene C2L_0004 meta-phenyl (SC to SC) C2L_0005 ortho-phenyl (SC to SC) C2L_0032 cyclopropane C2L_0035 1,2,3-triazole (C to N) C2L_0039 pyridine (2,4) C2L_0040 pyridine (2,4) C2L_0041 pyridine (2,5) C2L_0042 pyridine (2,5) C2L_0044 para-phenyl (SC to FC) C2L_0045 meta-phenyl (SC to FC) C2L_0046 ortho-phenyl (SC to FC) <ul> <li>F2L fragments</li> </ul> fragment name chemical structure AMIL2_0001 ammonium nitrogen AML2_0001_A1 trans-amide (C to N) AML2_0001_B1 trans-amide (N to C) ANIL2_0001 aniline nitrogen C2L_F_0035 1,2,3-triazole (N to C) C2L_F_0044 para-phenyl (FC to SC) C2L_F_0045 meta-phenyl (FC to SC) C2L_F_0046 ortho-phenyl (FC to SC) F2L_0004 piperazine (aniline N to ammonium N) F2L_0005 N-Me-amide (C to N) F2L_0006 N-Me-amide (N to C) SAM_YN2_A sulfonamide (YN2, S to N) SAM_YN2_B sulfonamide (YN2, N to S) SAM_YN3_A sulfonamide (YN3, S to N) SAM_YN3_B sulfonamide (YN3, N to S) YO oxygene (ether)"},{"location":"user_fragment/#default-rollout-fragment-set","title":"Default rollout fragment set","text":"<ul> <li>C2L fragments</li> </ul> fragment name chemical structure B1L_0000 (SC) hydrogen (SC) C2L_0001 para-phenyl (SC to SC) C2L_0003 methylene C2L_0005 ortho-phenyl (SC to SC) C2L_0044 para-phenyl (SC to FC) C2L_0046 ortho-phenyl (SC to FC) <ul> <li>F2L fragments</li> </ul> fragment name chemical structure AMIL2_0001 ammonium nitrogen AML2_0001_A1 trans-amide (C to N) AML2_0001_B1 trans-amide (N to C) C2L_F_0044 para-phenyl (FC to SC) C2L_F_0046 ortho-phenyl (FC to SC) YO oxygene (ether)"},{"location":"user_fragment/#fragment-set-at-terminal","title":"Fragment set at terminal","text":"<p>Regardless of the contents of the fragment set, the following fragments are used at the terminal.</p> fragment name chemical structure B1L_0000 (SC) hydrogen (SC) B1L_0000 (FC) hydrogen (FC) carboxylate carboxylate"},{"location":"input_details/atomname/","title":"Special atom names used in LigX","text":"<p>Special atom names are used in an initiator and fragments to ensure synthetic accessibility and remove unsuitable fragment linking. Atom names are categorized based on skeletal connector (SC) and functional group connector (FC). All of the atoms bound to the SC are carbon atoms.</p>"},{"location":"input_details/atomname/#1-atom-names-and-properties-bound-for-scs","title":"1. Atom names and properties bound for SCs.","text":"atom name description XC3 A sp3 carbon atom except for methylene type (XC3g) carbon atom. XC2 A sp2 carbon atom except for carbonyl carbon atom. XC1 A sp carbon atom of an alkyne. XC3g A sp3 carbon atom containing vicinal connectors such as methylene group. XCA A sp2 carbon atom of aromatic ring. <p>Note: The above atom names are actually used with an underscore and numbers appended. For details, refer to Initiator Preparation</p>"},{"location":"input_details/atomname/#2-atom-names-and-properties-bound-for-fcs","title":"2. Atom names and properties bound for FCs.","text":"atom name description YCA A carbonyl carbon atom. This atom accepts many fragments, allowing flexible utilization not only in carbonyl carbon but also in various substituents. YCO A carbon atom in the carboxylate fragment. YO An oxygen atom in an ether moiety. YN3 An ammonia type of nitrogen atom (positively charged). YN2 An aniline type of nitrogen atom (neutral nitrogen atom). YNA An amide type of nitrogen atom (neutral nitrogen atom). This atom accepts many fragments, allowing flexible utilization not only in amide nitrogen but also in various substituents. YS A sulfur atom in a thioether moiety. YSA A sulfur atom in a sulfonamide moiety. <p>Note: The above atom names are used without an underscore and numbers.</p>"},{"location":"input_details/atomname/#3-rule-of-the-linking-using-special-atom-names","title":"3. Rule of the linking using special atom names","text":"<p>In LigX program, the fragment linking which would generate chemically unstable or less synthetically accessible compounds can be removed based on the atom names between the fragments. During compound generation, the special atom names of the initiator and the used fragments are recorded. The linking permission can be determined by the combination between the atom name of each fragment and previous one or two atom recorded. Examples of combinations excluded by AAA are shown below.</p>"},{"location":"input_details/atomname/#a-two-atoms-combination","title":"a. Two-atoms combination","text":"<p>Two-atom combination listed in <code>LigX.LigX_core.distance_dict</code> defines the bond length between these atoms. Additionally, If the combination is not defined, the linking between this combination is not permitted. For example, a fragment linking between a sp2 carbon atom (XC2) and a nitrogen atom (YN2) generates enamine moiety that can be hydrolyzed in the presence of water. To eliminate the chance for yielding molecule with enamine moiety, the combination of XC2 and YN2 is not defined in the LigX program.</p>"},{"location":"input_details/atomname/#b-three-atoms-combination","title":"b. Three-atoms combination","text":"<p>In certain cases, chemically unstable structures can be generated through the two specific linking. For example, a sequential connection of a nitrogen atom (YN2), methylene group (XC3g), and an oxygen atom (YO) generates an hemiaminal moiety that can be hydrolyzed easily. To remove such structures, LigX defines the unacceptable sequence of three-atoms combination in <code>LigX.LigX_core.not_permitted_comb_dict</code>.</p>"},{"location":"input_details/atomname/#4-special-atom-names-only-used-for-the-positional-reference","title":"4. Special atom names only used for the positional reference","text":"<p>Fragment linking requires another special atom. The atom name is as shown in the table below. For details, refer to Initiator Preparation</p> atom name description CX_0 A carbon atom for the positional reference NX_0 A carbon atom for the positional reference RH_2 A hydrogen atom for the positional reference RC_2 A carbon atom for the positional reference RO_2 A oxygene atom for the positional reference RN_2 A nitrogen atom for the positional reference RS_2 A sulfur atom for the positional reference RCl_2 A chlorine atom for the positional reference RBr_2 A bromine atom for the positional reference RI_2 A iodine atom for the positional reference RF_2 A fluorine atom for the positional reference RP_2 A phosphorus atom for the positional reference"},{"location":"input_details/initiator/","title":"Initiator Preparation","text":"<p>An initiator can be created by the manual modification of the xyz file. An initiator must contain the following special element, which can be prepared by replacing the atom names in the original xyz file. It is recommended that a hydrogen atom is replaced to a skeletal connector (SC) or functional group connector (FC). </p>"},{"location":"input_details/initiator/#1-skeletal-connector-sc-or-functional-group-connector-fc","title":"1. skeletal connector (SC) or functional group connector (FC)","text":"<p>To define a SC, the atom name must be replaced to VC_2, and similarly, atom name VLB can be used to define a FC.</p>"},{"location":"input_details/initiator/#2-special-atom-names-bonded-to-sc-or-fc","title":"2. Special atom names bonded to SC or FC","text":"<p>A sequence of three connected atoms\u2014comprising an atom directly bonded to the SC or FC and the two atoms adjacent to it\u2014must be renamed. The atoms requiring renaming are schematically highlighted in the following chemical structures.</p> <pre>\n        H   H\n        |   |   |\nSC/FC \u2013 X - Y - C - H\n        |   |   |\n        H   O\n            |\n            H\n</pre> <p>The atoms labeled SC, FC, X and Y in the above figure should be renamed as specified in the following table. Special atom names used in LigX summarizes the requirements for each atomic name.</p>"},{"location":"input_details/initiator/#table-for-initiator-with-sc","title":"Table for initiator with SC","text":"SC X Y remarks VC_2 XC3_2 R'Z'_2 'Z' = H, C, O, N, S, Cl, Br, I, P, F VC_2 XC2_2 R'Z'_2 'Z' = H, C, O, N, S, Cl, Br, I, P, F VC_2 XC1_2 R'Z'_2 'Z' = H, C, O, N, S, Cl, Br, I, P, F VC_2 XC3g_2 R'Z'_2 'Z' = H, C, O, N, S, Cl, Br, I, P, F VC_2 XCA R'Z'_2 'Z' = H, C, O, N, S, Cl, Br, I, P, F <p>Note 'Z' used to define Y is a variable. The atom name for Y must be given based on the element.</p>"},{"location":"input_details/initiator/#table-for-initiator-with-fc","title":"Table for initiator with FC","text":"FC X Y remarks VLB YCA CX_0 or NX_0 CX_0: FC-C-C, NX_0: FC-C-N VLB YO CX_0 or NX_0 CX_0: FC-C-C, NX_0: FC-C-N VLB YN3 CX_0 fragment linking begins with ammonium nitrogen VLB YN2 CX_0 fragment linking begins with aniline nitrogen VLB YNA CX_0 fragment linking begins with other nitrogens VLB YS CX_0 fragment linking begins with sulger (thioether) VLB YSA YN3 fragment linking begins with sulger (sulfonamide) <p>Other elements attached on FC/SC are not supported.</p>"},{"location":"input_details/initiator/#3-terminal-atom-q-atom","title":"3. Terminal atom (Q atom)","text":"<p>To inform LigX program of the end of initiator, a terminal atom (Q atom) must be defined. This can be achieved by simply added \u201cQ\u201d after the element listed in the last line of the xyz file. example: H \u2192 HQ</p> <p>Note: If any of the atoms corresponding to SC, X, or Y appear in the last line of the file, please swap its line with that of another atom so that it does not remain on the final line before setting the Q atom.</p>"},{"location":"input_details/initiator/#4-example-of-xyz-files","title":"4. Example of xyz files","text":""},{"location":"input_details/initiator/#a-phenyl-group-with-sc","title":"a. Phenyl group with SC","text":"<pre><code>12\ninitiator_phenyl_SC\nXCA_2 31.430000 2.169000 29.525000\nRC_2 31.000999 0.823000 29.065001\nC 31.391001 0.264000 27.724001\nC 32.221001 1.083000 26.849001\nC 32.676998 2.428000 27.245001\nC 32.269001 2.945000 28.582001\nVC_2 31.106001 2.693000 30.707001\nH 30.385000 0.206000 29.702000\nH 31.056999 -0.720000 27.431000\nH 32.519001 0.708000 25.881001\nH 33.290001 3.010000 26.573000\nHQ 32.612999 3.932000 28.851999\n</code></pre> <p>Structural representation</p> <pre>\n       HQ       H\n        \\      /\n         C == C\n        /      \\\nVC_2 -XCA_2     C - H\n        \\\\    //\n        RC_2- C\n        /      \\\n       H        H\n</pre>"},{"location":"input_details/initiator/#b-phenyl-group-with-fc","title":"b. Phenyl group with FC","text":"<pre><code>12        \ninitiator_phenyl_FC\nYCA 31.430000 2.169000 29.525000\nCX_0 31.000999 0.823000 29.065001\nC 31.391001 0.264000 27.724001\nC 32.221001 1.083000 26.849001\nC 32.676998 2.428000 27.245001\nC 32.269001 2.945000 28.582001\nVLB 31.106001 2.693000 30.707001\nH 30.385000 0.206000 29.702000\nH 31.056999 -0.720000 27.431000\nH 32.519001 0.708000 25.881001\nH 33.290001 3.010000 26.573000\nHQ 32.612999 3.932000 28.851999\n</code></pre> <p>Structural representation</p> <pre>\n       HQ       H\n        \\      /\n         C == C\n        /      \\\nVLB - YCA      C - H\n        \\\\    //\n        CX_0- C\n        /      \\\n       H        H\n</pre>"},{"location":"input_details/initiator/#5-chargetxt","title":"5. charge.txt","text":"<p>It is a single-line text file containing only integer values for charge (1, 0, -1, etc.). example</p> <p>1</p>"},{"location":"input_details/proteins/","title":"Protein xyz file","text":"<p>The coordinates of the protein are converted to an xyz file, and the polar hydrogen atoms are manually renamed to D (Recommended but not essential).   LigX estimates interaction energies using element-specific standardized Lennard-Jones and Coulomb parameters. For hydrogen, two parameters are adopted: nonpolar hydrogen H and polar hydrogen D.</p> <p> To reduce computational cost, it is acceptable to manually remove atoms outside the region where ligands would be in close proximity.</p>"}]}